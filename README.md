# Effective Java

- Effective Java를 보고 정리한 자료입니다.
- 예제 코드는 Claude3 Opus 및 GPT 4o를 이용해서 만들었습니다.

## 목차

- 1장 들어가기

- 2장 객체 생성과 파괴

  > - [아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라](#아이템-1-생성자-대신-정적-팩터리-메서드를-고려하라)
  > - [아이템 2. 생성자에 매개변수가 많다면 빌더를 고려하라](#아이템-2-생성자에-매개변수가-많다면-빌더를-고려하라)
  > - [아이템 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라](#아이템-3-private-생성자나-열거-타입으로-싱글턴임을-보증하라)
  > - [아이템 4. 인스턴스화를 막으려거든 private 생성자를 사용하라](#아이템-4-인스턴스화를-막으려거든-private-생성자를-사용하라)
  > - [아이템 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라](#아이템-5-자원을-직접-명시하지-말고-의존-객체-주입을-사용하라)
  > - [아이템 6. 불필요한 객체 생성을 피하라](#아이템-6-불필요한-객체-생성을-피하라)
  > - [아이템 7. 다 쓴 객체 참조를 해제하라](#아이템-7-다-쓴-객체-참조를-해제하라)
  > - [아이템 8. finalizer와 cleaner 사용을 피하라](#아이템-8-finalizer와-cleaner-사용을-피하라)
  > - [아이템 9. try-finally보다는 try-with-resources를 사용하라](#아이템-9-try-finally보다는-try-with-resources를-사용하라)

- 3장 모든 객체의 공통 메서드

  > - [아이템 10. equals는 일반 규약을 지켜 재정의하라](#아이템-10-equals는-일반-규약을-지켜-재정의하라)
  > - [아이템 11. equals를 재정의하려거든 hashCode도 재정의하라](#아이템-11-equals를-재정의하려거든-hashcode도-재정의하라)
  > - [아이템 12. toString을 항상 재정의하라](#아이템-12-tostring을-항상-재정의하라)
  > - [아이템 13. clone 재정의는 주의해서 진행하라](#아이템-13-clone-재정의는-주의해서-진행하라)
  > - [아이템 14. Comparable을 구현할지 고려하라](#아이템-14-comparable을-구현할지-고려하라)

- 4장 클래스와 인터페이스

  > - [아이템 15. 클래스와 멤버의 접근 권한을 최소화하라](#아이템-15-클래스와-멤버의-접근-권한을-최소화하라)
  > - [아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라](#아이템-16-public-클래스에서는-public-필드가-아닌-접근자-메서드를-사용하라)
  > - [아이템 17. 변경 가능성을 최소화하라](#아이템-17-변경-가능성을-최소화하라)
  > - [아이템 18. 상속보다는 컴포지션을 사용하라](#아이템-18-상속보다는-컴포지션을-사용하라)
  > - [아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라](#아이템-19-상속을-고려해-설계하고-문서화하라-그러지-않았다면-상속을-금지하라)
  > - [아이템 20. 추상 클래스보다는 인터페이스를 우선하라](#아이템-20-추상-클래스보다는-인터페이스를-우선하라)
  > - [아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라](#아이템-21-인터페이스는-구현하는-쪽을-생각해-설계하라)
  > - [아이템 22. 인터페이스는 타입을 정의하는 용도로만 사용하라](#아이템-22-인터페이스는-타입을-정의하는-용도로만-사용하라)
  > - [아이템 23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라](#아이템-23-태그-달린-클래스보다는-클래스-계층구조를-활용하라)
  > - [아이템 24. 멤버 클래스는 되도록 static으로 만들라](#아이템-24-멤버-클래스는-되도록-static으로-만들라)
  > - [아이템 25. 톱레벨 클래스는 한 파일에 하나만 담으라](#아이템-25-톱레벨-클래스는-한-파일에-하나만-담으라)

- 5장 제네릭

  > - [아이템 26. 로 타입은 사용하지 말라](#아이템-26-로-타입은-사용하지-말라)
  > - [아이템 27. 비검사 경고를 제거하라](#아이템-27-비검사-경고를-제거하라)
  > - [아이템 28. 배열보다는 리스트를 사용하라](#아이템-28-배열보다는-리스트를-사용하라)
  > - [아이템 29. 이왕이면 제네릭 타입으로 만들라](#아이템-29-이왕이면-제네릭-타입으로-만들라)
  > - [아이템 30. 이왕이면 제네릭 메서드로 만들라](#아이템-30-이왕이면-제네릭-메서드로-만들라)
  > - [아이템 31. 한정적 와일드카드를 사용해 API 유연성을 높이라](#아이템-31-한정적-와일드카드를-사용해-api-유연성을-높이라)
  > - [아이템 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라](#아이템-32-제네릭과-가변인수를-함께-쓸-때는-신중하라)
  > - [아이템 33. 타입 안전 이종 컨테이너를 고려하라](#아이템-33-타입-안전-이종-컨테이너를-고려하라)

- 6장 열거 타입과 애너테이션

  > - [아이템 34. int 상수 대신 열거 타입을 사용하라](#아이템-34-int-상수-대신-열거-타입을-사용하라)
  > - [아이템 35. ordinal 메서드 대신 인스턴스 필드를 사용하라](#아이템-35-ordinal-메서드-대신-인스턴스-필드를-사용하라)
  > - [아이템 36. 비트 필드 대신 EnumSet을 사용하라](#아이템-36-비트-필드-대신-enumset을-사용하라)
  > - [아이템 37. ordinal 인덱싱 대신 EnumMap을 사용하라](#아이템-37-ordinal-인덱싱-대신-enummap을-사용하라)
  > - [아이템 38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라](#아이템-38-확장할-수-있는-열거-타입이-필요하면-인터페이스를-사용하라)
  > - [아이템 39. 명명 패턴보다 애너테이션을 사용하라](#아이템-39-명명-패턴보다-애너테이션을-사용하라)
  > - [아이템 40. @Override 애너테이션을 일관되게 사용하라](#아이템-40-override-애너테이션을-일관되게-사용하라)
  > - [아이템 41. 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라](#아이템-41-정의하려는-것이-타입이라면-마커-인터페이스를-사용하라)

- 7장 람다와 스트림

  > - [아이템 42. 익명 클래스보다는 람다를 사용하라](#아이템-42-익명-클래스보다는-람다를-사용하라)
  > - [아이템 43. 람다보다는 메서드 참조를 사용하라](#아이템-43-람다보다는-메서드-참조를-사용하라)
  > - [아이템 44. 표준 함수형 인터페이스를 사용하라](#아이템-44-표준-함수형-인터페이스를-사용하라)
  > - [아이템 45. 스트림은 주의해서 사용하라](#아이템-45-스트림은-주의해서-사용하라)
  > - [아이템 46. 스트림에서는 부작용 없는 함수를 사용하라](#아이템-46-스트림에서는-부작용-없는-함수를-사용하라)
  > - [아이템 47. 반환 타입으로는 스트림보다 컬렉션이 낫다](#아이템-47-반환-타입으로는-스트림보다-컬렉션이-낫다)
  > - [아이템 48. 스트림 병렬화는 주의해서 적용하라](#아이템-48-스트림-병렬화는-주의해서-적용하라)

- 8장 메서드

  > - [아이템 49. 매개변수가 유효한지 검사하라](#아이템-49-매개변수가-유효한지-검사하라)
  > - [아이템 50. 적시에 방어적 복사본을 만들라](#아이템-50-적시에-방어적-복사본을-만들라)
  > - [아이템 51. 메서드 시그니처를 신중히 설계하라](#아이템-51-메서드-시그니처를-신중히-설계하라)
  > - [아이템 52. 다중정의는 신중히 사용하라](#아이템-52-다중정의는-신중히-사용하라)
  > - [아이템 53. 가변인수는 신중히 사용하라](#아이템-53-가변인수는-신중히-사용하라)
  > - [아이템 54. null이 아닌, 빈 컬렉션이나 배열을 반환하라](#아이템-54-null이-아닌-빈-컬렉션이나-배열을-반환하라)
  > - [아이템 55. 옵셔널 반환은 신중히 하라](#아이템-55-옵셔널-반환은-신중히-하라)
  > - [아이템 56. 공개된 API 요소에는 항상 문서화 주석을 작성하라](#아이템-56-공개된-api-요소에는-항상-문서화-주석을-작성하라)

- 9장 일반적인 프로그래밍 원칙

  > - [아이템 57. 지역변수의 범위를 최소화하라](#아이템-57-지역변수의-범위를-최소화하라)
  > - [아이템 58. 전통적인 for 문보다는 for-each 문을 사용하라](#아이템-58-전통적인-for-문보다는-for-each-문을-사용하라)
  > - [아이템 59. 라이브러리를 익히고 사용하라](#아이템-59-라이브러리를-익히고-사용하라)
  > - [아이템 60. 정확한 답이 필요하다면 float와 double은 피하라](#아이템-60-정확한-답이-필요하다면-float와-double은-피하라)
  > - [아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하라](#아이템-61-박싱된-기본-타입보다는-기본-타입을-사용하라)
  > - [아이템 62. 다른 타입이 적절하다면 문자열 사용을 피하라](#아이템-62-다른-타입이-적절하다면-문자열-사용을-피하라)
  > - [아이템 63. 문자열 연결은 느리니 주의하라](#아이템-63-문자열-연결은-느리니-주의하라)
  > - [아이템 64. 객체는 인터페이스를 사용해 참조하라](#아이템-64-객체는-인터페이스를-사용해-참조하라)
  > - [아이템 65. 리플렉션보다는 인터페이스를 사용하라](#아이템-65-리플렉션보다는-인터페이스를-사용하라)
  > - [아이템 66. 네이티브 메서드는 신중히 사용하라](#아이템-66-네이티브-메서드는-신중히-사용하라)
  > - [아이템 67. 최적화는 신중히 하라](#아이템-67-최적화는-신중히-하라)
  > - [아이템 68. 일반적으로 통용되는 명명 규칙을 따르라](#아이템-68-일반적으로-통용되는-명명-규칙을-따르라)

- 10장 예외

  > - [아이템 69. 예외는 진짜 예외 상황에만 사용하라](#아이템-69-예외는-진짜-예외-상황에만-사용하라)
  > - [아이템 70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라](#아이템-70-복구할-수-있는-상황에는-검사-예외를-프로그래밍-오류에는-런타임-예외를-사용하라)
  > - [아이템 71. 필요 없는 검사 예외 사용은 피하라](#아이템-71-필요-없는-검사-예외-사용은-피하라)
  > - [아이템 72. 표준 예외를 사용하라](#아이템-72-표준-예외를-사용하라)
  > - [아이템 73. 추상화 수준에 맞는 예외를 던지라](#아이템-73-추상화-수준에-맞는-예외를-던지라)
  > - [아이템 74. 메서드가 던지는 모든 예외를 문서화하라](#아이템-74-메서드가-던지는-모든-예외를-문서화하라)
  > - [아이템 75. 예외의 상세 메시지에 실패 관련 정보를 담으라](#아이템-75-예외의-상세-메시지에-실패-관련-정보를-담으라)
  > - [아이템 76. 가능한 한 실패 원자적으로 만들라](#아이템-76-가능한-한-실패-원자적으로-만들라)
  > - [아이템 77. 예외를 무시하지 말라](#아이템-77-예외를-무시하지-말라)

- 11장 동시성

  > - [아이템 78. 공유 중인 가변 데이터는 동기화해 사용하라](#아이템-78-공유-중인-가변-데이터는-동기화해-사용하라)
  > - [아이템 79. 과도한 동기화는 피하라](#아이템-79-과도한-동기화는-피하라)
  > - [아이템 80. 스레드보다는 실행자, 태스크, 스트림을 애용하라](#아이템-80-스레드보다는-실행자-태스크-스트림을-애용하라)
  > - [아이템 81. wait와 notify보다는 동시성 유틸리티를 애용하라](#아이템-81-wait와-notify보다는-동시성-유틸리티를-애용하라)
  > - [아이템 82. 스레드 안전성 수준을 문서화하라](#아이템-82-스레드-안전성-수준을-문서화하라)
  > - [아이템 83. 지연 초기화는 신중히 사용하라](#아이템-83-지연-초기화는-신중히-사용하라)
  > - [아이템 84. 프로그램의 동작을 스레드 스케줄러에 기대지 말라](#아이템-84-프로그램의-동작을-스레드-스케줄러에-기대지-말라)

- 12장 직렬화
  > - [아이템 85. 자바 직렬화의 대안을 찾으라](#아이템-85-자바-직렬화의-대안을-찾으라)
  > - [아이템 86. Serializable을 구현할지는 신중히 결정하라](#아이템-86-serializable을-구현할지는-신중히-결정하라)
  > - [아이템 87. 커스텀 직렬화 형태를 고려해보라](#아이템-87-커스텀-직렬화-형태를-고려해보라)
  > - [아이템 88. readObject 메서드는 방어적으로 작성하라](#아이템-88-readobject-메서드는-방어적으로-작성하라)
  > - [아이템 89. 인스턴스 수를 통제해야 한다면 readResolve보다는 열거 타입을 사용하라](#아이템-89-인스턴스-수를-통제해야-한다면-readresolve보다는-열거-타입을-사용하라)
  > - [아이템 90. 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라](#아이템-90-직렬화된-인스턴스-대신-직렬화-프록시-사용을-검토하라)

## 아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라

### 정적 팩터리 메서드가 생성자보다 좋은 점

- 이름을 가질 수 있음.
- 호출될 때마다 인스턴스를 새로 생성하지 않아도 됨.
- 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있음.
- 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있음
- 정적 팰터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 됨.

### 정적 팩터리 메서드가 생성자보다 나쁜 점

- 상속을 하려면 `public`이나 `protected` 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없음.
- 정적 팩터리 메서드는 프로그래머가 찾기 어려움.

### 정적 팩터리 메서드에 흔히 사용하는 명명 방식들

- `from`: 하나의 매개변수를 받아 해당 타입의 인스턴스를 생성하는 메서드. 예를 들어, `Date.from(instant)`는 Instant를 받아 Date 객체를 생성함.
- `of`: 여러 매개변수를 받아 적절한 타입의 인스턴스를 생성하는 메서드. 예를 들어, `Set.of(elements)`는 여러 요소를 받아 `Set`을 생성함.
- `valueOf`: `from`과 비슷하지만 더 명시적인 의미를 가지고, 주어진 매개변수를 사용하여 인스턴스를 생성함. 예를 들어, `Integer.valueOf(String)`는 문자열을 받아 `Integer` 객체를 생성함.
- `instance / getInstance`: 인스턴스를 반환하는 메서드. 보통 싱글톤 패턴에서 사용됨. 예를 들어, `Calendar.getInstance()`는 `Calendar`의 인스턴스를 반환함.
- `create / newInstance`: 새로운 인스턴스를 생성하는 메서드. 예를 들어, `MyClass.create()`는 `MyClass`의 새로운 인스턴스를 생성함.
- `getType`: 특정 타입의 인스턴스를 반환하는 메서드. `getInstance`와 같으나, 새성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 씀. 예를 들어, `FileStore.getFileStore(path)`는 `FileStore` 인스턴스를 반환함.
- `newType`: 새로운 타입의 인스턴스를 생성하는 메서드. 예를 들어, `BufferedReader.newBufferedReader(reader)`는 `BufferedReader`의 새로운 인스턴스를 생성함.
- `type`: 인스턴스를 반환하는 일반적인 메서드. 예를 들어, `TypeFactory.type()`은 특정 타입의 인스턴스를 반환함.

### 요약

- 정적 팩터리 메서드와 public 생성자는 각자의 쓰임새가 있으니 상대적인 장단점을 이해하고 사용하는 것이 좋음. 그렇다고 하더라도 정적 팩터리를 사용하는게 유리한 경우가 더 많으므로 무작적 public 생성자를 제공하던 습관이 있으면 고칠 것.

## 아이템 2. 생성자에 매개변수가 많다면 빌더를 고려하라

### 내용

### 핵심 정리

- 생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면 빌더 패턴을 선택하는 것이 나음. 매개 변수 중 다수가 필수가 아니거나 같은 타입이면 더 그러함. 빌더는 점층적 생성자보다 클라이언트 코드를 읽고 쓰시가 훨씬 간결하고, 자바 빈즈보다 안전함.

## 아이템 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라

## 아이템 4. 인스턴스화를 막으려거든 private 생성자를 사용하라

## 아이템 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

## 아이템 6. 불필요한 객체 생성을 피하라

## 아이템 7. 다 쓴 객체 참조를 해제하라

## 아이템 8. finalizer와 cleaner 사용을 피하라

### finalizer

- Java 9 이전에는 객체가 가비지 컬렉션 대상이 될 때 정리 작업을 수행하는 방법으로 `finalize` 메서드를 사용했음.
- `finalize` 메서드는 객체가 더 이상 참조되지 않을 때 가비지 컬렉터에 의해 호출되지만, 호출 시점이 명확하지 않으며 성능에 큰 영향을 미칠 수 있음.

### Cleaner

- Java 9에서 도입된 `Cleaner`는 `finalize` 메서드를 대체하는 더 안전하고 성능이 좋은 방법.
- `Cleaner`는 백그라운드 스레드를 사용하여 등록된 객체가 가비지 컬렉션 대상이 될 때 정리 작업을 수행함.
- `Cleaner`는 명시적으로 객체를 정리할 수 있는 방법을 제공하여, 정리 작업의 타이밍을 좀 더 제어할 수 있음.

### finalizer와 Cleaner 사용을 피해야 하는 이유

- **Unpredictable Timing**: `finalize` 메서드는 가비지 컬렉터에 의해 호출되므로, 호출 시점이 예측할 수 없음. 이는 리소스 해제 작업이 지연되어 리소스 누수 문제를 일으킬 수 있음.
- **Performance Overhead**: `finalize` 메서드는 성능에 큰 영향을 줄 수 있음. 가비지 컬렉션 과정에서 추가적인 오버헤드가 발생하기 때문임.
- **Unreliability**: `finalize` 메서드가 실행되지 않을 수도 있음. 가비지 컬렉터가 객체를 수집하기 전에 프로그램이 종료될 수 있기 때문임.
- **Security Risks**: `finalize` 메서드를 잘못 사용하면 보안 문제가 발생할 수 있음. 특히, `finalize` 메서드를 오버라이드하여 객체를 재생성하면 예기치 않은 동작을 유발할 수 있음.

### 요약

- **`cleaner`(자바 8까지는 `finalizer`)는 안전망 역할이나 중요하지 않은 네이티브 자원 회수로용으로만 사용할 것.**
- `finalizer`는 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요함.
- `cleaner`는 `finalizer`보다는 덜 위험하지만, 여전히 예측할 수 없고, 느리고, 일반적으로 불필요함.
- `finalizer`와 `cleaner`로는 제때 실행되어야 하는 작업은 절대 할 수 없음.
- 상태를 영구적으로 수정하는 작업에서는 절대 `finalizer`나 `cleaner`에 의존해서는 안됨.
- `finalizer`와 `cleaner`는 심각한 성능 문제도 동반함.
- `finalizer`를 사용한 클래스는 `finalizer` 공격에 노출되어 심각한 보안 문제를 일으킬 수도 있음.
- `final`이 아닌 클래스를 `finalizer` 공격으로부터 방어하려면 아무일도 하지 않는 `finalizer`를 만들고 `final`로 선언할 것.
- `finalizer`나 `cleaner`를 대신해서 `AutoClosable`을 쓸 것.

## 아이템 9. try-finally보다는 try-with-resources를 사용하라

### try-finally

- `try` 블록에서 리소스를 사용하고, `finally` 블록에서 리소스를 명시적으로 해제해야 함.
- 코드가 길어지고 가독성이 떨어질 수 있음.
- 리소스 해제 로직을 개발자가 직접 작성해야 함.
- 예외 발생 시 리소스 해제 로직이 실행되지 않을 수 있음.

### try-with-resources

- Java 7부터 도입된 기능으로, 리소스를 자동으로 해제해주는 구문.
- `try` 블록에서 사용할 리소스를 소괄호 안에 선언함.
- 리소스 객체는 `AutoCloseable` 인터페이스를 구현해야 함.
- `try` 블록이 종료되면 자동으로 리소스의 `close()` 메서드가 호출되어 리소스가 해제됨.
- 코드가 간결해지고 가독성이 좋아짐.
- 예외 발생 여부와 관계없이 항상 리소스가 해제됨.

### 요약

- 꼭 회수해야 하는 자원을 다룰 때는 try-finally가 아닌 try-with-resources를 사용할 것.

## 아이템 10. `equals`는 일반 규약을 지켜 재정의하라

### 다음 상황에 해당한다면 `equals`를 재정의하지 말 것.

- 각 인스턴스가 본질걱으로 고유함. 예를 들어, 대부분의 `Thread` 클래스 인스턴스는 본질적으로 고유함. 두 개의 `Thread` 인스턴스가 논리적으로 같다고 비교하는 것은 의미가 없음. 각 스레드는 고유한 실행 흐름을 나타내기 때문임.

```java
Thread thread1 = new Thread();
Thread thread2 = new Thread();
System.out.println(thread1.equals(thread2)); // false, 본질적으로 고유
```

- 인스턴스의 '논리적 동치성(logical equality)'를 검사할 일이 없음. 예를 들어, 유틸리티 클래스(특정 기능이나 작업을 수행하는 정적 메서드들을 모아놓은 클래스)나 상수 클래스의 경우 논리적 동치성을 검사할 일이 없음.

```java
public class UtilityClass {
    // 이 클래스는 논리적 동치성을 검사할 필요가 없음
    private UtilityClass() {}
    public static void utilityMethod() {
        // ...
    }
}
```

- 상위 클래스에서 재정의한 `equals`가 하위 클래스에도 딱 들어 맞음. 예를 들어, `AbstractList` 클래스는 `List` 인터페이스를 구현하는 모든 하위 클래스에 대해 적절한 `equals` 메서드를 제공함. 따라서 `ArrayList`나 `LinkedList`에서 `equals`를 재정의할 필요가 없음.

```java
List<Integer> list1 = new ArrayList<>(Arrays.asList(1, 2, 3));
List<Integer> list2 = new LinkedList<>(Arrays.asList(1, 2, 3));
System.out.println(list1.equals(list2)); // true, 상위 클래스의 equals가 적절히 동작
```

- 클래스가 `private`이거나 `package-private`이고 `equals` 메서드를 호출할 일이 없음. 예를 들어, 내부적으로만 사용되는 `private` 클래스는 외부에서 접근할 수 없으므로 `equals` 메서드를 호출할 일이 없음.

```java
class PackagePrivateClass {
    private int value;

    PackagePrivateClass(int value) {
        this.value = value;
    }

    // equals를 재정의할 필요 없음
}

public class Main {
    public static void main(String[] args) {
        PackagePrivateClass obj1 = new PackagePrivateClass(1);
        PackagePrivateClass obj2 = new PackagePrivateClass(1);

        // obj1.equals(obj2) 호출할 일이 없음
    }
}

```

### `equals` 메서드를 재정의할 때 따라야하는 일반 규약

- **반사성(reflexivity)**: `null`이 아닌 모든 참조 값 `x`에 대해, `x.equals(x)`는 `true`임.
- **대칭성(symmetry)**: `null`이 아닌 모든 참조 값 `x`와 `y`에 대해, `x.equals(y)`가 `true`이면 `y.equals(x)`도 `true`임.
  > - `equals` 규약을 어기면 그 객체를 사용하는 다른 객체들이 어떻게 반응할지 알 수 없음.
- **추이성(transitivity)**: `null`이 아닌 모든 참조 값 `x`, `y`, `z`에 대해, `x.equals(y)`가 `true`이고 `y.equals(z)`가 `true`이면 `x.equals(z)`도 `true`임.
  > - 구체 클래스를 확장해 새로운 ㄱ밧을 추가하면서 `equals` 규약을 만족시킬 방법은 존재하지 않음.
- **일관성(consistency)**: `null`이 아닌 모든 참조 값 `x`와 `y`에 대해, `x.equals(y)`를 반복해서 호출하면 항상 `true`를 반환하거나 항상 `false`를 반환함.
  > - `equals`의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안 됨.
- **null 아님(non-nullity)**: `null`이 아닌 모든 참조 값 `x`에 대해, `x.equals(null)`는 `false`임.

### `equals` 메서드 구현 방법

1. `==` 연산자를 사용해 입력이 자기 자신의 참조인지 확인할 것.
2. `instanceof` 연산자로 입력이 올바른 타입인지 확인할 것.
3. 입력을 올바른 타입으로 형변환할 것.
4. 입력 객체와 자기 자신의 대응되는 '핵심' 필드들이 모두 일치하는지 하나씩 검사할 것.

### `equals` 메서드 구현 시 주의사항

- `equals`를 재정의할 땐, `hashCode`도 반드시 재정의 할 것.
- 너무 복잡하게 해결하려 하지 말 것.
- `Object` 외의 타입을 매개변수로 받는 `equals` 메서드는 선언하지 말 것.

### 핵심 정리

- 꼭 필요한 경우가 아니면 `equals`를 재정의하지 말 것. 많은 경우에 `Object`의 `equals`가 여러분이 원하는 비교를 정확히 수행함. 재정의해야 할 때는 그 클래스의 핵심 필드를 모두 빠짐없이, 다섯가지 규약을 확실히 지켜가며 비교해야함.

## 아이템 11. `equals`를 재정의하려거든 `hashCode`도 재정의하라

### `hashCode`

- `hashCode` 메서드는 객체의 해시 코드를 반환하는 메서드로, 해시 기반 컬렉션(`HashMap`, `HashSet` 등)에서 객체를 빠르게 검색하거나 저장하는 데 사용됨. 자바의 기본 `hashCode` 메서드는 객체의 메모리 주소를 기반으로 해시 코드를 생성함.

### `Object` 명세에서 발췌한 `hashCode` 관련 규약

- **일관성**: `equals` 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 `hashCode` 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 함. 단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없음.
- **equals와의 관계**: `equals(Object)`가 두 객체를 같다고 판단했다면, 두 객체의 `hashCode`는 똑같은 값을 반환해야 함.
- **해시 충돌 최소화**: `equals(Object)`가 두 객체를 다르다고 판단했더라도, 두 객체의 `hashCode`는 서로 다른 값을 반환할 필요는 없음. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아짐.
- 서로 다른 두 객체가 같은 해시 코드를 가질 수 있음. 이는 해시 충돌이며, 해시 기반 자료구조는 이를 처리할 수 있는 방법을 가지고 있음. 예를 들어, `HashMap`은 같은 해시 코드를 가진 여러 객체를 처리할 수 있음. 해시 충돌을 처리하는 방법은 다양함. 대표적으로 두 가지가 있음.
  > - **체이닝(Chaining)**: 동일한 해시 코드를 가진 객체들을 연결 리스트로 저장함. 해시 테이블의 각 버킷은 연결 리스트를 참조함.
  > - **개방 주소법(Open Addressing)**: 충돌이 발생하면 다른 버킷을 찾아 객체를 저장함.

### `hashCode` 사용시 주의할 점.

- `equals`을 재정의한 클래스 모두에서 `hashCode`도 재정의해야함.
- `hashCode` 재정의를 잘못했을 때 크게 문제가 되는 조항은, 논리적으로 같은 객체는 같은 해시 코드를 반환해야 한다는 것.

### 좋은 `hashCode` 작성 요령

- **일관된 `equals` 구현**: 두 객체가 `equals` 메서드에 의해 같다고 판단된다면, 두 객체는 반드시 같은 `hashCode`를 반환해야 함.
- **다양한 필드 사용**: 가능한 많은 중요한 필드를 포함하여 해시 코드를 계산함.
- **31 사용**: 소수인 31을 사용하여 각 필드를 조합함. 31은 홀수이고 소수로, 해시 충돌을 줄이는 데 도움이 됨.
- **기본형 필드**: 기본형 필드는 직접 포함함. 예를 들어, `int` 필드는 직접 해시 코드 계산에 사용함.
- **참조형 필드**: 참조형 필드는 해당 객체의 `hashCode`를 포함함. 만약 필드가 `null`일 수 있다면 `null`인 경우를 처리함.
- **예제 코드**

```java
@Override
public int hashCode() {
    int result = 17; // 임의의 비-zero 정수로 시작
    result = 31 * result + (name != null ? name.hashCode() : 0); // name 필드의 해시코드 포함
    result = 31 * result + age; // age 필드의 해시코드 포함
    return result;
}
```

### 핵심 정리

- `equals`를 재정의할 때는 `hashCode`도 반드시 재정의해야함. 그렇지 않으면 프로그램이 제대로 동작하지 않음. 재정의한 `hashCode`는 `Object`의 API 문서에 기술된 이란 규약을 따라야 하며, 서로 다른 인스턴스라면 되도록 해시코드도 서로 다르게 구현해야 함. 이렇게 구현하기가 어렵지는 않지만 조금 따분함 일임. AutoValue 프레임워크를 사용하면 `equals`와 `hashCode`를 자동으로 만들어줌.

## 아이템 12. `toString`을 항상 재정의하라

### `toString`을 재정의해야 하는 이유

- `toString`을 잘 구현한 클래스는 사용하기에 훨신 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉬움.
- 실제로 사용할 때는 `toString`은 그 객체가 가진 주요 정보를 반환하는 것이 좋음.
- 포맷을 명시하든 아니든 의도는 명확히 밝여야 함.
- `toString`이 반환한 값에 포함된 정보를 얻어놀 수 있는 API를 제공할 것.

### 핵심 요약

- 모든 구체 클래스에서 `Object`의 `toString`을 재정의할 것. 상위 클래스에서 이미 알맞게 재정의한 경우는 예외임. `toString`을 재정의한 클래스는 사용하기도 즐겁고 그 클래스를 사용한 시스템을 디버깅하기 쉽게 해줌. `toString`은 해당 객체에 관한 명확하고 유용한 정보를 읽기 좋은 형태로 반환해야 함.

## 아이템 13. `clone` 재정의는 주의해서 진행하라

### `clone`의 특징

- 실무에서 `Cloneable`을 구현한 클래스는 `clone` 메서드를 `public`으로 제공하며, 사용자는 당연히 복제가 제대로 이뤄지리라 기대함.
- `Cloneable` 아키텍처는 '가변 객체를 참조하는 필드는 `final`로 선언하라'는 일반 용법과 충돌함.
- `public`인 `clone`메서드에서는 `throws` 절을 없애야 함.
- `Cloneable`을 이미 구현한 클래슥 아니라면, 복사 생성자와 복사 팩터리라는 더 나은 객체 복사 방식을 제공할 수 있음.

### 핵심 정리

- `Cloneable`이 몰고 온 모든 문제를 되짚어봤을 때, 새로운 인터페이스를 만들 때는 절대 `Cloneable`을 확장해서는 안 되며, 새로운 클래스로 이를 구현해서는 안 됨. `final` 클래스라면 `Cloneable`을 구현해도 위험이 크진 않지만, 성능 최적화 관점에서 검토한 후 별다른 문제가 없을 때만 드물게 허용해야 함. 기본 원칙은 '복제 기능은 생성자 팩터리를 이용하는 게 최고'라는 것. 단, 배열만은 `clone` 메서드 방식이 가장 깔끔한, 이 규칙의 합당한 예외라 할 수 있음.

## 아이템 14. `Comparable`을 구현할지 고려하라

### `CompareTo` 일반 규약

- **반사성 (Reflexive)**: `x.compareTo(x) == 0`이어야 함. 어떤 객체도 자신과 비교할 때 0을 반환해야 함.
- **대칭성 (Symmetric)**: `x.compareTo(y) == -y.compareTo(x)`여야 함. 만약 `x`가 `y`보다 작으면 `y`는 `x`보다 커야 하고, 그 반대도 성립해야 함.
- **추이성 (Transitive)**: `x.compareTo(y) > 0`이고 `y.compareTo(z) > 0`이면 `x.compareTo(z) > 0`이어야 함. 즉, `x`가 `y`보다 크고 `y`가 `z`보다 크면 `x`는 `z`보다 커야 함.
- **일관성 (Consistency)**: `x.compareTo(y) == 0`이면, `x.compareTo(z)`와 `y.compareTo(z)`의 결과는 항상 같아야 함. 객체의 비교 결과가 일관성이 있어야 함.
- **`Null` 비교**: `compareTo` 메서드는 `null`을 비교 대상으로 할 수 없음. `NullPointerException`을 던져야 함.

### `CompareTo`를 사용할 때 주의할 점

- `compareTo` 메서드에서 관계 연산자 `<`와 `>`를 사용하는 이전 방식은 거추장스럽고 오류를 유발하니, 이제는 추천하지 않음.

### 핵심 정리

- 순서를 고려해야 하는 값 클래스를 작성한다면 꼭 `Comparable` 인터페이스를 구현하여, 그 인스턴스들을 쉽게 정렬하고, 검색하고, 비교 기능을 제공하는 컬렉션과 어우러지도록 해야 함. `compareTo` 메서드에서 필드의 값을 비교할 때 `<`와 `>`연산자는 쓰지 말아야 함. 그 대신 박싱된 기본 타입 클래스가 제공하는 정적 `compare` 메서드나 `Comparator` 인터페이스가 제공하는 비교자 생성 메서드를 사용할 것.

## 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라

### 핵심 정리

- 프로그램 요소의 접근성은 가능한 한 최소한으로 할 것. 꼭 필요한 것만 골라 최소한의 `public` API를 설게할 것. 그 외에는 클래스, 인터페이스, 멤버가 의도치 않게 API로 공개되는 일이 없도록 해야 함. `public` 클래스는 상수용 `public static final`필드 외에는 어떠한 `public` 필드도 가져서는 안 됨. `public static final` 필드가 참조하는 객체가 불변인지 확인할 것.

## 아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

## 아이템 17. 변경 가능성을 최소화하라

## 아이템 18. 상속보다는 컴포지션을 사용하라

## 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

## 아이템 20. 추상 클래스보다는 인터페이스를 우선하라

## 아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라

## 아이템 22. 인터페이스는 타입을 정의하는 용도로만 사용하라

## 아이템 23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라

## 아이템 24. 멤버 클래스는 되도록 static으로 만들라

## 아이템 25. 톱레벨 클래스는 한 파일에 하나만 담으라

## 아이템 26. 로 타입은 사용하지 말라

### 제네릭 클래스 / 제네릭 인터페이스

- 제네릭 클래스와 인터페이스는 클래스나 인터페이스를 정의할 때 타입 파라미터를 사용하는 것을 의미함. 이를 통해 코드의 재사용성을 높이고 타입 안전성을 보장할 수 있음.

```java
public class GenericClass<T> {
    private T value;

    public GenericClass(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}

public interface GenericInterface<T> {
    void doSomething(T t);
}
```

### 매개변수화 타입

- 매개변수화 타입은 제네릭 클래스나 인터페이스를 인스턴스화할 때 구체적인 타입을 지정하는 것을 의미함. 이를 통해 제네릭 타입을 사용할 때 타입 안전성을 제공받을 수 있음.

```java
GenericClass<String> stringInstance = new GenericClass<>("Hello");
GenericClass<Integer> integerInstance = new GenericClass<>(123);
```

### 로 타입

- 로 타입(raw type)은 제네릭 타입에서 타입 매개변수를 지정하지 않은 경우를 의미함. 로 타입을 사용하면 제네릭이 제공하는 타입 안전성 검사가 무력화됨.

```java
GenericClass rawInstance = new GenericClass("Raw Type");
```

### 제네릭 타입과 instanceof

- 제네릭 타입에 대해 `instanceof`를 사용할 때는 로 타입을 사용해야 함. 이를 통해 제네릭 타입의 인스턴스를 안전하게 검사할 수 있음.

```java
if (o instanceof GenericClass) {
    GenericClass<?> genericInstance = (GenericClass<?>) o;
}
```

### 와일드카드

- 와일드카드는 제네릭 타입을 사용할 때 다양한 타입을 처리할 수 있도록 유연성을 제공하는 기법. 주로 ?를 사용하여 상위 또는 하위 타입 경계를 지정함.

```java
public void printList(List<?> list) {
    for (Object elem : list) {
        System.out.println(elem);
    }
}
```

### 요약

- **로 타입을 사용하면 런타입에 예외가 일어날 수 있으니 사용하면 안됨. 로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐임.**
- 로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 됨.
- `List<Object>`와 같은 매개변수화 타입을 사용할 때와 달리 `List`같은 로 타입을 사용하면 타입 안전성을 잃게 됨.
- `class` 리터럴에는 로 타입을 써야함.
- `다음은 제네릭 타입에 instanceof`를 사용하는 올바른 예제.

```java
if (o instanceof Set) {
  Set<?> s= Set<?> o
}
```

## 아이템 27. 비검사 경고를 제거하라

### 공변성과 실체화

#### 공변성 (Covariance)

- **배열의 공변성**: 배열은 공변(covariant). 즉, 배열의 타입 간에 상속 관계가 있으면, 배열 타입 간에도 같은 상속 관계가 있음. 예를 들어, `Integer`는 `Number`의 서브타입이기 때문에 `Integer[]`는 `Number[]`의 서브타입. 이는 유연하게 보일 수 있지만, 타입 안전성 문제를 일으킬 수 있음.

```java
public class CovariantExample {
    public static void main(String[] args) {
        Number[] numbers = new Integer[10]; // Integer[] is a subtype of Number[]
        numbers[0] = 1; // Valid
        numbers[1] = 1.5; // ArrayStoreException at runtime, because 1.5 is not an Integer
    }
}
```

#### 실체화 (Reification)

- **배열의 실체화**: 배열은 런타임 시 실제 타입 정보를 유지함. 즉, 배열의 타입이 런타임에도 유지됨. 따라서 배열에 잘못된 타입의 요소를 저장하려고 하면 런타임에 예외가 발생할 수 있음.
- **제네릭 타입의 타입 소거**: 반면, 제네릭 타입은 컴파일 시 타입 검사를 수행하지만, 런타임에는 타입 정보가 지워짐. 이를 타입 소거(type erasure)라고 함. 따라서 제네릭 타입의 인스턴스는 런타임에 타입 정보를 유지하지 않음.

```java
import java.util.ArrayList;
import java.util.List;

public class ReificationExample {
    public static void main(String[] args) {
        // 배열은 실체화됨
        Object[] objectArray = new Integer[1];
        objectArray[0] = "Hello"; // ArrayStoreException at runtime

        // 제네릭 타입은 실체화되지 않음 (타입 소거)
        List<Integer> integerList = new ArrayList<>();
        List rawList = integerList; // Raw type, no generic type information
        rawList.add("Hello"); // No compile-time error, but introduces type-safety issue
        Integer integer = integerList.get(0); // ClassCastException at runtime
    }
}
```

### 요약

- **비검사 경고는 중요하니 무시하지 말 것. 모든 비검사 경고는 런타임에 `ClassCastException`을 일으킬 수 있는 잠재적 가능성을 뜻하니 최선을 다해서 제거할 것.**
- 할 수 있는 모든 비검사 경고를 제거할 것.
- 경고를 제거할 수는 없지만 타입 안전하다고 확신할 수 있다면 `@SupressWarnings("unchecked")` 애너테이션을 달아 숨길 것.
- `@SupressWarnings`은 항상 가능한 좁은 범위에 적용할 것.
- `SupressWarnings("unchecked")` 애너테이션을 사용할 때면 그 경고를 무시해도 안전한 이유를 항상 주석으로 남겨야 함.

## 아이템 28. 배열보다는 리스트를 사용하라

### 요약

- 배열과 제네릭에는 매우 다른 타입 규칙이 적용됨. 배열은 공변이고 실체화되는 반면, 제네릭은 불공변이고 타입 정보가 소거됨. 그 결과 배열은 런타입에는 타입 안전하지만 컴파일 타임에는 그렇지 않음. 제네릭은 반대임. 그래서 둘을 섞어 쓰기른 쉽지 않음. 둘을 섞어 쓰다가 컴파일 오류나 경고를 만나면, 가장 먼저 배열을 리스트로 대체하는 방법을 생각해야 함.

## 아이템 29. 이왕이면 제네릭 타입으로 만들라

## 아이템 30. 이왕이면 제네릭 메서드로 만들라

## 아이템 31. 한정적 와일드카드를 사용해 API 유연성을 높이라

## 아이템 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라

## 아이템 33. 타입 안전 이종 컨테이너를 고려하라

## 아이템 34. int 상수 대신 열거 타입을 사용하라

## 아이템 35. ordinal 메서드 대신 인스턴스 필드를 사용하라

## 아이템 36. 비트 필드 대신 EnumSet을 사용하라

## 아이템 37. ordinal 인덱싱 대신 EnumMap을 사용하라

## 아이템 38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라

## 아이템 39. 명명 패턴보다 애너테이션을 사용하라

## 아이템 40. @Override 애너테이션을 일관되게 사용하라

## 아이템 41. 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라

## 아이템 42. 익명 클래스보다는 람다를 사용하라

### 요약

- **타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다의 모든 매개변수 타입은 생략할 것.**
- 람다는 이름이 없고 문서화도 못함. 따라서 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야 함.
- 람다를 직렬화하는 일은 극히 삼가야 함.
- 익명 클래스는 (함수형 인터페이스가 아닌) 타입의 인스턴스를 만들 때만 사용할 것.

## 아이템 43. 람다보다는 메서드 참조를 사용하라

### 메서드 참조 유형

- 정적 메서드 참조 (Static Method Reference)
  > - **형식**: `ClassName::staticMethodName`
  > - **설명**: 클래스의 정적 메서드를 참조함.
- 한정적 인스턴스 메서드 참조 (Bound Instance Method Reference)
  > - **형식**: `instanceRef::instanceMethodName`
  > - **설명**: 특정 객체의 인스턴스 메서드를 참조함.
- 비한정적 인스턴스 메서드 참조 (Unbound Instance Method Reference)
  > - **형식**: `ClassName::instanceMethodName`
  > - **설명**: 클래스의 인스턴스 메서드를 참조하지만, 객체 인스턴스는 람다 표현식의 첫 번째 매개변수로 전달됨.
- 클래스 생성자 메서드 참조 (Class Constructor Reference)
  > - **형식**: `ClassName::new`
  > - **설명**: 클래스의 생성자를 참조함.
- 배열 생성자 메서드 참조 (Array Constructor Reference)
  > - **형식**: `TypeName[]::new`
  > - **설명**: 배열의 생성자를 참조함.

### 요약

- 메서드 참조 쪽이 짧고 명확하다면 메서드 참조를 쓰고, 그렇지 않을때만 람다를 활용할 것.

## 아이템 44. 표준 함수형 인터페이스를 사용하라

### 기본 함수형 인터페이스

- `UnaryOperator<T>`
  > - **개념**: 같은 타입의 인수와 반환값을 가지는 함수형 인터페이스. 입력값을 연산하여 동일한 타입의 결과를 반환함.
  > - **메서드**: `T apply(T t)`
- `BinaryOperator<T>`
  > - **개념**: 두 개의 같은 타입 인수를 받아 동일한 타입의 결과를 반환하는 함수형 인터페이스. 주로 두 값을 연산하는 데 사용됨.
  > - **메서드**: `T apply(T t1, T t2)`
- `Predicate<T>`
  > - **개념**: 인수를 받아 `boolean` 값을 반환하는 함수형 인터페이스. 주로 조건 검사에 사용됨.
  > - **메서드**: `boolean test(T t)`
- `Function<T, R>`
  > - **개념**: 인수를 받아 다른 타입의 결과를 반환하는 함수형 인터페이스. 주로 값을 변환하는 데 사용됨.
  > - **메서드**: `R apply(T t)`
- `Supplier<T>`
  > - **개념**: 인수 없이 결과만 반환하는 함수형 인터페이스. 주로 값을 생성하는 데 사용됨.
  > - **메서드**: `T get()`
- `Consumer<T>`
  > - **개념**: 인수를 받지만 결과를 반환하지 않는 함수형 인터페이스. 주로 값을 소비하는 데 사용됨.
  > - **메서드**: `void accept(T t)`

### 요약

- **입력값과 반환값에 함수형 인터페이스 타입을 활용할 것. 보통은 `java.util.function` 패키지의 표준 함수형 인터페이스를 사용하는 것이 가장 좋은 선택.**
- 필요한 용도에 맞는 게 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용할 것.
- 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지 말 것.
- 직접 만든 함수형 인터페이스에는 항상 `@FunctionalInterface`를 활용할 것.

## 아이템 45. 스트림은 주의해서 사용하라

## 아이템 46. 스트림에서는 부작용 없는 함수를 사용하라

## 아이템 47. 반환 타입으로는 스트림보다 컬렉션이 낫다

## 아이템 48. 스트림 병렬화는 주의해서 적용하라

## 아이템 49. 매개변수가 유효한지 검사하라

## 아이템 50. 적시에 방어적 복사본을 만들라

## 아이템 51. 메서드 시그니처를 신중히 설계하라

## 아이템 52. 다중정의는 신중히 사용하라

## 아이템 53. 가변인수는 신중히 사용하라

## 아이템 54. null이 아닌, 빈 컬렉션이나 배열을 반환하라

## 아이템 55. 옵셔널 반환은 신중히 하라

## 아이템 56. 공개된 API 요소에는 항상 문서화 주석을 작성하라

## 아이템 57. 지역변수의 범위를 최소화하라

## 아이템 58. 전통적인 for 문보다는 for-each 문을 사용하라

## 아이템 59. 라이브러리를 익히고 사용하라

## 아이템 60. 정확한 답이 필요하다면 float와 double은 피하라

## 아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하라

## 아이템 62. 다른 타입이 적절하다면 문자열 사용을 피하라

## 아이템 63. 문자열 연결은 느리니 주의하라

## 아이템 64. 객체는 인터페이스를 사용해 참조하라

## 아이템 65. 리플렉션보다는 인터페이스를 사용하라

## 아이템 66. 네이티브 메서드는 신중히 사용하라

## 아이템 67. 최적화는 신중히 하라

## 아이템 68. 일반적으로 통용되는 명명 규칙을 따르라

## 아이템 69. 예외는 진짜 예외 상황에만 사용하라

### 요약

- **예외는 예외 상황에서 쓸 의도로 설계됨. 정상적인 제어 흐름에서는 사용해서는 안되며, 이를 프로그래머에게 강요하는 API를 만들어서도 안 됨**.
- 예외는 오직 예외 상황에서만 써야함. 절대로 일상적인 제어 흐름용으로 쓰여선 안 됨.
- 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 함.

## 아이템 70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

### 검사 예외(Checked Exception)

- 검사 예외는 `Exception` 클래스의 서브 클래스 중 `RuntimeException`을 상속하지 않는 예외.
- 컴파일러가 프로그램의 컴파일 시점에 검사 예외 처리 여부를 검사함.
- 검사 예외가 발생할 수 있는 메서드를 호출할 때는 반드시 `try-catch` 블록으로 예외를 처리하거나 `throws` 키워드로 예외를 선언해야 함.
- 대표적인 검사 예외로는 `IOException`, `SQLException` 등이 있음.
- 검사 예외는 일반적으로 복구 가능한 예외 상황을 나타내며, 예외 처리를 강제함으로써 안정성을 높임.
- 컴파일 시점에 예외 처리 여부를 검사함.
- 예외 처리를 강제함으로써 안정성을 높일 수 있음.

### 비검사 예외(Unchecked Exception)

- 비검사 예외는 `RuntimeException` 클래스의 서브 클래스.
- 컴파일러가 프로그램의 컴파일 시점에 비검사 예외 처리 여부를 검사하지 않음.
- 비검사 예외는 `try-catch` 블록으로 예외를 처리하거나 `throws` 키워드로 예외를 선언하지 않아도 됨.
- 대표적인 비검사 예외로는 `NullPointerException`, `ArrayIndexOutOfBoundsException` 등이 있음.
- 비검사 예외는 일반적으로 프로그램의 오류나 잘못된 사용으로 인한 예외 상황을 나타내며, 개발자가 예외 처리를 선택적으로 할 수 있음.
- 컴파일 시점에 예외 처리 여부를 검사하지 않음.
- 예외 처리를 선택적으로 할 수 있어 유연성을 제공함.

### Throwable

- `Throwable`은 Java에서 모든 예외와 오류의 최상위 클래스.
- `Throwable`은 크게 두 가지 하위 클래스로 나뉨
  > - `Exception`: 일반적인 예외를 나타내는 클래스. 프로그램 실행 중에 발생할 수 있는 예외 상황을 나타냄.
  > - `Error`: 심각한 오류를 나타내는 클래스. 일반적으로 프로그램으로 처리할 수 없는 시스템 레벨의 오류를 나타냄.
- `Throwable`을 직접 사용하는 경우는 드뭄. 대부분의 경우 `Exception`이나 `Error` 클래스 또는 그 하위 클래스를 사용하여 예외와 오류를 처리함.
- 하지만 `Throwable`은 예외와 오류의 공통적인 기능을 제공하며, 다음과 같은 상황에서 사용될 수 있음.
  > - 모든 예외와 오류를 한 번에 처리해야 할 때
  > - 예외와 오류에 대한 공통적인 로깅이나 보고 기능을 구현할 때
  > - 사용자 정의 예외 클래스를 만들 때 (예: `extends Exception` 또는 `extends Throwable`)

### 요약

- 복구할 수 있는 상황이면 검사 예외를, 프로그래밍 오류라면 비검사 예외를 던질 것. 확실하지 않다면 비검사 예외를 던질 것. 검사 예외도 아니고 런타임 에외도 아닌 `throwable`은 정의하지도 말 것.
- 호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용할 것.
- 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용할 것.
- 구현하는 비검사 `throwable`은 모두 `RuntimeException`의 하위 클래스여야 함.

## 아이템 71. 필요 없는 검사 예외 사용은 피하라

### 요약

- 검사 예외는 프로그램의 안전성을 높여주지만, 남용하면 쓰기 고통스러운 API를 낳음. API 호출자가 예외 상황에서 복구할 방법이 없다면 예외를 던질 것. 복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 우선 옵셔널을 반환해도 될지 고민할 것. 옵셔널만으로는 상황을 처리하기에 충분할 정보를 제공할 수 없을 때만 검사 예외를 던질 것.

## 아이템 72. 표준 예외를 사용하라

### 자주 사용하는 Exception

- `IllegalArgumentException`: 메서드에 전달된 인수가 유효하지 않을 때 발생함. 예를 들어, 메서드가 특정 범위의 값을 요구하지만 잘못된 값이 전달된 경우에 발생함.
- `IllegalStateException`: 객체의 상태가 메서드 호출에 적합하지 않을 때 발생함. 객체가 사용하기 전에 올바르게 초기화되지 않았거나, 이미 종료된 객체에 대해 작업을 시도하는 경우에 발생함.
- `NullPointerException`: `null` 참조를 통해 객체의 메서드나 필드에 접근하려고 할 때 발생함. 예를 들어, `null` 객체의 메서드를 호출하거나 필드를 참조할 때 발생함.
- `IndexOutOfBoundsException`: 배열이나 리스트에서 잘못된 인덱스를 사용할 때 발생함. 예를 들어, 배열의 범위를 벗어난 인덱스에 접근하려고 할 때 발생함.
- `ConcurrentModificationException`: 컬렉션이 반복되는 동안 구조적으로 변경될 때 발생함. 예를 들어, 컬렉션의 요소를 반복하면서 요소를 추가하거나 제거할 때 발생함.
- `UnsupportedOperationException`: 호출된 메서드가 지원되지 않는 작업을 시도할 때 발생함. 주로 변경할 수 없는 컬렉션에서 요소를 추가하거나 제거할 때 발생함.

### 요약

- `Exception`, `RuntimeException`, `Throwable`, `Error`는 직접 재사용하지 말것.
- 인수 값이 무엇이었든 어차피 실패했을 거라면 `IllegalStateException`을, 그렇지 않으면 `IllegalArgumentException`을 던질 것.

## 아이템 73. 추상화 수준에 맞는 예외를 던지라

### 예외 번역(Exception Translation)

- 예외 번역은 낮은 수준의 예외를 더 높은 수준의 예외로 변환하는 것을 의미함. 이 방법은 API 계층 간의 예외 처리를 단순화하고, 특정 구현 세부 사항에 대한 의존성을 줄이는 데 도움이 됨. 예를 들어, 데이터베이스 계층에서 발생한 예외를 서비스 계층에서 처리하기 쉽도록 변환할 수 있음.

### 예외 연쇄(Exception Chaining)

- 예외 연쇄는 하나의 예외가 다른 예외의 원인이 될 때 사용됨. 예외 연쇄를 통해 예외의 발생 원인을 추적할 수 있으며, 각 계층에서 예외를 감싸서 던질 때 원래의 예외를 원인(cause)으로 포함시켜 전달함.

### 요약

- **아래 계층의 예외를 예방하거나 스스로 처리할 수 업속, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용할 것. 이때 예외 연쇄를 이용하면 상위 계층에는 맥락에 어울리는 고수준 예외를 던지면서 근본 원인도 함께 알려주어 오류를 분석하기에 좋음.**
- 상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 함.
- 무턱대고 예외를 전파하는 것보다야 예외 번역이 우수한 방법이지만, 남용해서는 곤란함.

## 아이템 74. 메서드가 던지는 모든 예외를 문서화하라

### `@throws`

- `@throws` 태그는 JavaDoc에서 사용되어 메서드가 던질 가능성이 있는 예외를 문서화하는 데 사용됨. 이 태그를 사용하면 메서드가 어떤 예외를 던질 수 있는지, 그리고 그 예외가 발생할 수 있는 상황을 명확하게 설명할 수 있음. 이를 통해 다른 개발자가 해당 메서드를 사용할 때 발생할 수 있는 예외 상황을 예측하고 적절히 처리할 수 있도록 도와줌.

### JavaDoc 생성하기

```sh
javadoc -d docs -sourcepath src src/chapter10/Item74_DocumentAllThrownExceptions.java
```

### 요약

- 메서드가 던질 가능성이 있는 모든 예외를 문서화할 것. 검사 예외든 비검사 예외든, 추상 메서드든 구체 메서드든 모두 마찬가지임. 문서화에는 자바독의 `@throws`태그를 사용할 것. 검사 예외만 메서드 선언의 `throws` 문에 일일이 선언하고, 비검사 예외는 메서드 선언에는 기입하지 말 것. 발생 가능한 예외를 문서로 남기지 않으면 다른 사람이 그 클래스나 인터페이스를 효과적으로 사용하기 어렵거나 심지어 불가능할 수 있음.
- 검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 `@throws` 태그를 사용하여 정확히 문서화 할 것.
- 메서드가 던질 수 있는 예외를 각각 ` @throws` 태그로 문서화하되, 비검사 예외는 메서드 선언의 `throws` 선언에 넣지 말 것.
- 한 클래스에 정의된 많은 메서드가 같은 이유로 같은 예외를 던진다면 그 예외를 클래스 설명헤 추가하는 방법도 있음.

## 아이템 75. 예외의 상세 메시지에 실패 관련 정보를 담으라

## 아이템 76. 가능한 한 실패 원자적으로 만들라

## 아이템 77. 예외를 무시하지 말라

## 아이템 78. 공유 중인 가변 데이터는 동기화해 사용하라

## 아이템 79. 과도한 동기화는 피하라

## 아이템 80. 스레드보다는 실행자, 태스크, 스트림을 애용하라

## 아이템 81. wait와 notify보다는 동시성 유틸리티를 애용하라

## 아이템 82. 스레드 안전성 수준을 문서화하라

## 아이템 83. 지연 초기화는 신중히 사용하라

## 아이템 84. 프로그램의 동작을 스레드 스케줄러에 기대지 말라

## 아이템 85. 자바 직렬화의 대안을 찾으라

## 아이템 86. Serializable을 구현할지는 신중히 결정하라

## 아이템 87. 커스텀 직렬화 형태를 고려해보라

## 아이템 88. readObject 메서드는 방어적으로 작성하라

## 아이템 89. 인스턴스 수를 통제해야 한다면 readResolve보다는 열거 타입을 사용하라

## 아이템 90. 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라

## 클래스명

Chapter 6: Enums and Annotations

public class Item34_UseEnumsInsteadOfIntConstants {}
public class Item35_UseInstanceFieldsInsteadOfOrdinals {}
public class Item36_UseEnumSetInsteadOfBitFields {}
public class Item37_UseEnumMapInsteadOfOrdinalIndexing {}
public class Item38_ExtensibleEnumsViaInterfaces {}
public class Item39_PreferAnnotationsToNamingPatterns {}
public class Item40_ConsistentlyUseOverrideAnnotation {}
public class Item41_UseMarkerInterfacesToDefineTypes {}

Chapter 8: Methods

public class Item49_CheckParametersForValidity {}
public class Item50_DefensiveCopiesForMutableFields {}
public class Item51_DesignMethodSignaturesCarefully {}
public class Item52_UseOverloadingJudiciously {}
public class Item53_CarefullyUseVarargs {}
public class Item54_ReturnEmptyCollectionsOrArraysNotNulls {}
public class Item55_ReturnOptionalsJudiciously {}
public class Item56_AlwaysDocumentAPIElems {}

Chapter 9: General Programming

public class Item57_MinimizeLocalVariableScope {}
public class Item58_PreferForEachLoopsToTraditionalForLoops {}
public class Item59_KnowAndUseLibraries {}
public class Item60_AvoidFloatAndDoubleForExactAnswers {}
public class Item61_PreferPrimitiveTypesToBoxedPrimitives {}
public class Item62_AvoidStringsWhereOtherTypesAreMoreAppropriate {}
public class Item63_BeWaryOfStringConcatenation {}
public class Item64_ReferToObjectsByTheirInterfaces {}
public class Item65_PreferInterfacesToReflection {}
public class Item66_UseNativeMethodsJudiciously {}
public class Item67_AvoidUnnecessaryOptimizations {}
public class Item68_AdhereToGeneralNamingConventions {}
